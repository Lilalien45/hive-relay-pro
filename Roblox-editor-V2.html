<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">

<title>Roblox Next Level Web Studio Viewer</title>

<script src="https://cdn.jsdelivr.net/npm/three@0.160/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>

<style>

body{
margin:0;
overflow:hidden;
background:#0f1117;
color:white;
font-family:Arial;
}

#ui{
position:absolute;
width:100%;
height:100%;
pointer-events:none;
}

.panel{
background:#000a;
padding:10px;
border-radius:8px;
pointer-events:auto;
}

#menu{
position:absolute;
top:10px;
left:50%;
transform:translateX(-50%);
}

#explorer{
position:absolute;
left:10px;
top:70px;
width:230px;
height:420px;
overflow:auto;
}

#properties{
position:absolute;
right:10px;
top:70px;
width:260px;
max-height:320px;
overflow:auto;
}

button{
background:#222;
color:white;
border:none;
padding:6px 12px;
margin:4px;
border-radius:6px;
cursor:pointer;
}

</style>

</head>

<body>

<div id="ui">

<div id="menu" class="panel">
<input type="file" id="placeLoader">
</div>

<div id="explorer" class="panel">
<h3>Explorer</h3>
<div id="explorerTree"></div>
</div>

<div id="properties" class="panel">
<h3>Properties</h3>
<div id="propertiesData"></div>
</div>

</div>

<script>

/* CORE */

let scene,camera,renderer,xmlDoc=null;
let camTarget=new THREE.Vector3();
let instanceMap=new Map();

/* NETWORK CAMERA SIM */

let remoteCameras=[];
let networkMode="private";

/* PHYSICS STYLE CAMERA */

let camAngleX=0;
let camAngleY=0;

/* INIT */

function initEngine(){

scene=new THREE.Scene();

camera=new THREE.PerspectiveCamera(
75,
window.innerWidth/window.innerHeight,
0.1,
50000
);

renderer=new THREE.WebGLRenderer({
antialias:true,
alpha:true
});

renderer.setSize(window.innerWidth,window.innerHeight);

document.body.appendChild(renderer.domElement);

/* Lighting */

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));

/* Grid */

let grid=new THREE.GridHelper(3000,300);
grid.material.opacity=0.3;
grid.material.transparent=true;
scene.add(grid);

/* Fake multiplayer cameras */

spawnRemoteCameras();

/* Controls */

initControls();

animate();

}

/* MULTIPLAYER CAMERA VISUALIZATION */

function spawnRemoteCameras(){

for(let i=0;i<4;i++){

let cam=new THREE.Mesh(
new THREE.ConeGeometry(15,35,8),
new THREE.MeshBasicMaterial({wireframe:true})
);

cam.position.set(
Math.random()*300-150,
50,
Math.random()*300-150
);

remoteCameras.push(cam);
scene.add(cam);

}

}

/* ORBIT PHYSICS CAMERA */

function initControls(){

let dragging=false;
let lx=0,ly=0;

window.addEventListener("pointerdown",e=>{
dragging=true;
lx=e.clientX;
ly=e.clientY;
});

window.addEventListener("pointerup",()=>dragging=false);

window.addEventListener("pointermove",e=>{
if(!dragging)return;

camAngleX+=(e.clientX-lx)*0.005;
camAngleY+=(e.clientY-ly)*0.005;

lx=e.clientX;
ly=e.clientY;
});

window.addEventListener("wheel",e=>{
camera.position.z+=e.deltaY*0.5;
});

}

/* LOOP */

let time=0;

function animate(){

requestAnimationFrame(animate);

time+=0.01;

updateAnimations();
updateRemoteCameras();
updateCameraOrbit();

renderer.render(scene,camera);

}

/* CAMERA ORBIT */

function updateCameraOrbit(){

let radius=600;

camera.position.x=camTarget.x+Math.cos(camAngleX)*radius;
camera.position.z=camTarget.z+Math.sin(camAngleX)*radius;
camera.position.y=camTarget.y+Math.sin(camAngleY)*radius;

camera.lookAt(camTarget);

}

/* REMOTE CAMERA VISUALS */

function updateRemoteCameras(){

remoteCameras.forEach((c,i)=>{

c.rotation.y+=0.01;

if(networkMode==="host"){
c.visible=true;
}else if(networkMode==="private"){
c.visible=false;
}else{
c.visible=i<2;
}

});

}

/* FILE LOAD */

placeLoader.addEventListener("change",e=>{

let f=e.target.files[0];
if(!f)return;

let r=new FileReader();

r.onload=()=>{
parseRobloxXML(r.result);
};

r.readAsText(f);

});

/* PARSER */

function parseRobloxXML(text){

xmlDoc=new DOMParser().parseFromString(text,"text/xml");

buildExplorer();
buildScene();

}

/* EXPLORER */

function buildExplorer(){

let tree=document.getElementById("explorerTree");
tree.innerHTML="";

xmlDoc.documentElement.childNodes.forEach(n=>{
if(n.nodeName==="Item"){
tree.appendChild(buildExplorerNode(n));
}
});

}

function buildExplorerNode(node){

let div=document.createElement("div");
div.style.marginLeft="10px";

let name=node.querySelector("Properties > string[name='Name']");
let label=name?name.textContent:node.getAttribute("class");

let btn=document.createElement("button");
btn.style.width="100%";
btn.textContent=label;
btn.onclick=()=>showProperties(node);

div.appendChild(btn);

node.childNodes.forEach(c=>{
if(c.nodeName==="Item"){
div.appendChild(buildExplorerNode(c));
}
});

return div;

}

/* PROPERTIES */

function showProperties(node){

let panel=document.getElementById("propertiesData");

let html="<b>"+(
node.querySelector("Properties > string[name='Name']")?.textContent
||node.getAttribute("class")
)+"</b><br>";

node.querySelectorAll("Properties > *").forEach(p=>{
html+=p.getAttribute("name")+": "+p.textContent+"<br>";
});

panel.innerHTML=html;

}

/* RENDER INSTANCES */

function parseVector3(s){
let a=s.split(",");
return{
x:parseFloat(a[0])||1,
y:parseFloat(a[1])||1,
z:parseFloat(a[2])||1
};
}

function renderInstance(node,parent){

let cls=node.getAttribute("class");
let obj=null;

if(cls.includes("Part")){

let size=node.querySelector("Properties > Vector3[name='Size']");
let s=size?parseVector3(size.textContent):{x:1,y:1,z:1};

let mat=new THREE.MeshStandardMaterial({
color:Math.random()*0xffffff
});

obj=new THREE.Mesh(
new THREE.BoxGeometry(s.x,s.y,s.z),
mat
);

}

else if(cls.includes("MeshPart")){

let mat=new THREE.MeshStandardMaterial({
color:Math.random()*0xffffff
});

obj=new THREE.Mesh(
new THREE.SphereGeometry(20,32,32),
mat
);

}

else if(cls.includes("Gui")){

obj=new THREE.Group();

let guiPlane=new THREE.Mesh(
new THREE.PlaneGeometry(8,4),
new THREE.MeshBasicMaterial({
color:0xffffff,
side:THREE.DoubleSide
})
);

obj.add(guiPlane);

}

else if(cls==="Model"||cls==="Folder"){
obj=new THREE.Group();
}

if(obj){

instanceMap.set(node,obj);

(parent?parent:scene).add(obj);

node.childNodes.forEach(c=>{
if(c.nodeName==="Item"){
renderInstance(c,obj);
}
});

}

}

/* SCENE BUILD */

function buildScene(){

scene.clear();

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));

let grid=new THREE.GridHelper(3000,300);
grid.material.opacity=0.3;
grid.material.transparent=true;

scene.add(grid);

xmlDoc.documentElement.childNodes.forEach(n=>{
if(n.nodeName==="Item"){
renderInstance(n,null);
}
});

autoFrameCamera();

}

/* CAMERA FRAME */

function autoFrameCamera(){

let box=new THREE.Box3().setFromObject(scene);
let center=box.getCenter(new THREE.Vector3());
let size=box.getSize(new THREE.Vector3());

camTarget.copy(center);

camera.position.set(
center.x+size.x*3+300,
center.y+size.y*2+300,
center.z+size.z*3+300
);

}

/* ANIMATIONS */

function updateAnimations(){

instanceMap.forEach((obj,node)=>{

let anim=node.querySelector("Properties > string[name='AnimationId']");

if(anim){
obj.rotation.y=Math.sin(time)*1.5;
}

});

}

/* START */

initEngine();

</script>

</body>
</html>
