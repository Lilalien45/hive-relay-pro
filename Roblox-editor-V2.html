<script>

/* ENGINE STATE */

let scene,camera,renderer,xmlDoc=null;
let camTarget=new THREE.Vector3();
let instanceMap=new Map();

let animationTime=0;

/* CAMERA ORBIT STATE */

let dragging=false;
let lastX=0;
let lastY=0;

let camYaw=0;
let camPitch=0;
let pinchDist=0;

/* INIT ENGINE */

function initEngine(){

scene=new THREE.Scene();

let w=window.innerWidth;
let h=window.innerHeight;

camera=new THREE.PerspectiveCamera(
75,w/h,0.1,50000
);

/* Faster rendering settings */
renderer=new THREE.WebGLRenderer({
antialias:true,
powerPreference:"high-performance"
});

renderer.setSize(w,h);
document.body.appendChild(renderer.domElement);

/* Lighting */
scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
scene.add(new THREE.GridHelper(2000,200));

initControls();
animate();

}

/* CAMERA CONTROLS (PC + MOBILE ORBIT) */

function initControls(){

/* POINTER ROTATION */

window.addEventListener("pointerdown",e=>{
dragging=true;
lastX=e.clientX;
lastY=e.clientY;
});

window.addEventListener("pointerup",()=>{
dragging=false;
pinchDist=0;
});

window.addEventListener("pointermove",e=>{

if(!dragging)return;

if(e.pointerType==="mouse" || e.touches?.length===1){

camYaw += (e.clientX-lastX)*0.005;
camPitch += (e.clientY-lastY)*0.005;

camPitch=Math.max(-1.4,Math.min(1.4,camPitch));

lastX=e.clientX;
lastY=e.clientY;

}

});

/* MOBILE PINCH ZOOM */

window.addEventListener("touchmove",e=>{

if(e.touches.length===2){

let t1=e.touches[0];
let t2=e.touches[1];

let dx=t1.clientX-t2.clientX;
let dy=t1.clientY-t2.clientY;

let dist=Math.sqrt(dx*dx+dy*dy);

if(pinchDist!==0){
let delta=dist-pinchDist;
camera.position.z+=delta*0.3;
}

pinchDist=dist;

}

});

/* PC ZOOM */

window.addEventListener("wheel",e=>{
camera.position.z+=e.deltaY*0.5;
});

}

/* LOOP */

function animate(){

requestAnimationFrame(animate);

animationTime+=0.01;

updateAnimations();
updateCameraOrbit();

camera.lookAt(camTarget);
renderer.render(scene,camera);

}

/* ORBIT CAMERA PHYSICS */

function updateCameraOrbit(){

let radius=600;

camera.position.x=
camTarget.x+Math.cos(camYaw)*radius;

camera.position.z=
camTarget.z+Math.sin(camYaw)*radius;

camera.position.y=
camTarget.y+Math.sin(camPitch)*radius;

}

/* SESSION MODE */

function setMode(mode){
alert("Session Mode: "+mode);
}

/* FILE LOAD */

placeLoader.addEventListener("change",e=>{
let f=e.target.files[0];
if(!f)return;

let r=new FileReader();
r.onload=()=>{
parseRobloxXML(r.result);
};
r.readAsText(f);

});

/* PARSER */

function parseRobloxXML(text){

xmlDoc=new DOMParser().parseFromString(text,"text/xml");

buildExplorer();
buildScene();

}

/* EXPLORER */

function buildExplorer(){

let tree=document.getElementById("explorerTree");
tree.innerHTML="";

xmlDoc.documentElement.childNodes.forEach(n=>{
if(n.nodeName==="Item"){
tree.appendChild(buildExplorerNode(n));
}
});

}

function buildExplorerNode(node){

let div=document.createElement("div");
div.style.marginLeft="12px";

let name=node.querySelector("Properties > string[name='Name']");
let label=name?name.textContent:node.getAttribute("class");

let btn=document.createElement("button");
btn.style.width="100%";
btn.textContent=label;
btn.onclick=()=>showProperties(node);

div.appendChild(btn);

node.childNodes.forEach(c=>{
if(c.nodeName==="Item"){
div.appendChild(buildExplorerNode(c));
}
});

return div;

}

/* PROPERTY VIEW */

function showProperties(node){

let panel=document.getElementById("propertiesData");

let html="<b>"+(
node.querySelector("Properties > string[name='Name']")?.textContent
||node.getAttribute("class")
)+"</b><br>";

node.querySelectorAll("Properties > *").forEach(p=>{
html+=p.getAttribute("name")+": "+p.textContent+"<br>";
});

panel.innerHTML=html;

}

/* VECTOR PARSER */

function parseVector3(s){
let a=s.split(",");
return{
x:parseFloat(a[0])||1,
y:parseFloat(a[1])||1,
z:parseFloat(a[2])||1
};
}

/* INSTANCE RENDER */

function renderInstance(node,parent){

let cls=node.getAttribute("class");
let obj=null;

if(cls.includes("Part")){

let size=node.querySelector("Properties > Vector3[name='Size']");
let s=size?parseVector3(size.textContent):{x:1,y:1,z:1};

let mat=new THREE.MeshStandardMaterial({
color:Math.random()*0xffffff
});

obj=new THREE.Mesh(
new THREE.BoxGeometry(s.x,s.y,s.z),
mat
);

}

else if(cls.includes("Gui")){

obj=new THREE.Group();

let plane=new THREE.Mesh(
new THREE.PlaneGeometry(5,3),
new THREE.MeshBasicMaterial({
color:0xffffff,
side:THREE.DoubleSide
})
);

obj.add(plane);

}

else if(cls==="Model"||cls==="Folder"){
obj=new THREE.Group();
}

if(obj){

instanceMap.set(node,obj);

(parent?parent:scene).add(obj);

node.childNodes.forEach(c=>{
if(c.nodeName==="Item"){
renderInstance(c,obj);
}
});

}

}

/* BUILD SCENE */

function buildScene(){

scene.clear();

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
scene.add(new THREE.GridHelper(2000,200));

xmlDoc.documentElement.childNodes.forEach(n=>{
if(n.nodeName==="Item"){
renderInstance(n,null);
}
});

autoFrameCamera();

}

/* CAMERA FRAME */

function autoFrameCamera(){

let box=new THREE.Box3().setFromObject(scene);
let center=box.getCenter(new THREE.Vector3());
let size=box.getSize(new THREE.Vector3());

camTarget.copy(center);

let dist=Math.max(size.x,size.y,size.z)*2+300;

camera.position.set(
center.x+dist,
center.y+dist,
center.z+dist
);

}

/* ANIMATION SIM */

function updateAnimations(){

instanceMap.forEach((obj,node)=>{

let anim=node.querySelector("Properties > string[name='AnimationId']");

if(anim){
obj.rotation.y=Math.sin(animationTime)*1.5;
}

});

}

/* START */

initEngine();

</script>
