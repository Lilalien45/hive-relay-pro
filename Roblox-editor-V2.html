<script>

/* ENGINE STATE */

let scene,camera,renderer,xmlDoc=null;
let camTarget=new THREE.Vector3();
let instanceMap=new Map();
let networkMode="private";
let animationTime=0;

/* CAMERA PHYSICS */

let dragging=false;
let camYaw=0;
let camPitch=0;

/* GRID TEXTURE FLOOR */

function createGridFloor(){

const tex=new THREE.TextureLoader().load(
"https://i.imgur.com/4k9Q9Vf.png"
);

tex.wrapS=THREE.RepeatWrapping;
tex.wrapT=THREE.RepeatWrapping;
tex.repeat.set(200,200);

let mat=new THREE.MeshBasicMaterial({
map:tex,
transparent:true,
opacity:0.85,
side:THREE.DoubleSide
});

let floor=new THREE.Mesh(
new THREE.PlaneGeometry(5000,5000),
mat
);

floor.rotation.x=-Math.PI/2;
floor.position.y=-10;

scene.add(floor);

}

/* INIT ENGINE */

function initEngine(){

scene=new THREE.Scene();

let w=window.innerWidth;
let h=window.innerHeight;

/* Faster performance renderer */
renderer=new THREE.WebGLRenderer({
antialias:false,
powerPreference:"high-performance"
});

renderer.setSize(w,h);
document.body.appendChild(renderer.domElement);

/* Lighting */
scene.add(new THREE.AmbientLight(0xffffff,0.9));

camera=new THREE.PerspectiveCamera(
75,w/h,0.1,50000
);

/* Grid floor instead of line grid */
createGridFloor();

initControls();
animate();

}

/* CAMERA CONTROLS (SMOOTH ORBIT) */

function initControls(){

let lastX=0,lastY=0;

window.addEventListener("pointerdown",e=>{
dragging=true;
lastX=e.clientX;
lastY=e.clientY;
});

window.addEventListener("pointerup",()=>dragging=false);

window.addEventListener("pointermove",e=>{
if(!dragging)return;

camYaw+=(e.clientX-lastX)*0.005;
camPitch+=(e.clientY-lastY)*0.005;

camPitch=Math.max(-1.4,Math.min(1.4,camPitch));

lastX=e.clientX;
lastY=e.clientY;
});

window.addEventListener("wheel",e=>{
camera.position.z+=e.deltaY*0.4;
});

}

/* MAIN LOOP */

function animate(){

requestAnimationFrame(animate);

animationTime+=0.01;

updateAnimations();
updateCameraOrbit();

renderer.render(scene,camera);

}

/* CAMERA ORBIT PHYSICS */

function updateCameraOrbit(){

let radius=600;

camera.position.x=
camTarget.x+Math.cos(camYaw)*radius;

camera.position.z=
camTarget.z+Math.sin(camYaw)*radius;

camera.position.y=
camTarget.y+Math.sin(camPitch)*radius;

camera.lookAt(camTarget);

}

/* SESSION MODE */

function setMode(mode){
networkMode=mode;
alert("Session Mode: "+mode);
}

/* FILE LOAD */

placeLoader.addEventListener("change",e=>{
let f=e.target.files[0];
if(!f)return;

let r=new FileReader();
r.onload=()=>{
parseRobloxXML(r.result);
};
r.readAsText(f);

});

/* PARSER */

function parseRobloxXML(text){

xmlDoc=new DOMParser().parseFromString(text,"text/xml");

buildExplorer();
buildScene();

}

/* EXPLORER */

function buildExplorer(){

let tree=document.getElementById("explorerTree");
tree.innerHTML="";

xmlDoc.documentElement.childNodes.forEach(n=>{
if(n.nodeName==="Item"){
tree.appendChild(buildExplorerNode(n));
}
});

}

function buildExplorerNode(node){

let div=document.createElement("div");
div.style.marginLeft="12px";

let name=node.querySelector("Properties > string[name='Name']");
let label=name?name.textContent:node.getAttribute("class");

let btn=document.createElement("button");
btn.style.width="100%";
btn.textContent=label;
btn.onclick=()=>showProperties(node);

div.appendChild(btn);

node.childNodes.forEach(c=>{
if(c.nodeName==="Item"){
div.appendChild(buildExplorerNode(c));
}
});

return div;

}

/* PROPERTIES */

function showProperties(node){

let panel=document.getElementById("propertiesData");

let html="<b>"+(
node.querySelector("Properties > string[name='Name']")?.textContent
||node.getAttribute("class")
)+"</b><br>";

node.querySelectorAll("Properties > *").forEach(p=>{
html+=p.getAttribute("name")+": "+p.textContent+"<br>";
});

panel.innerHTML=html;

}

/* VECTOR PARSER */

function parseVector3(s){
let a=s.split(",");
return{
x:parseFloat(a[0])||1,
y:parseFloat(a[1])||1,
z:parseFloat(a[2])||1
};
}

/* INSTANCE RENDER */

function renderInstance(node,parent){

let cls=node.getAttribute("class");
let obj=null;

if(cls.includes("Part")){

let size=node.querySelector("Properties > Vector3[name='Size']");
let s=size?parseVector3(size.textContent):{x:1,y:1,z:1};

let mat=new THREE.MeshStandardMaterial({
color:Math.random()*0xffffff
});

obj=new THREE.Mesh(
new THREE.BoxGeometry(s.x,s.y,s.z),
mat
);

}

else if(cls.includes("Gui")){

obj=new THREE.Group();

let plane=new THREE.Mesh(
new THREE.PlaneGeometry(5,3),
new THREE.MeshBasicMaterial({
color:0xffffff,
side:THREE.DoubleSide
})
);

obj.add(plane);

}

else if(cls==="Model"||cls==="Folder"){
obj=new THREE.Group();
}

if(obj){

instanceMap.set(node,obj);

(parent?parent:scene).add(obj);

node.childNodes.forEach(c=>{
if(c.nodeName==="Item"){
renderInstance(c,obj);
}
});

}

}

/* BUILD SCENE */

function buildScene(){

scene.clear();

/* Re-add lighting */
scene.add(new THREE.AmbientLight(0xffffff,0.9));

createGridFloor();

xmlDoc.documentElement.childNodes.forEach(n=>{
if(n.nodeName==="Item"){
renderInstance(n,null);
}
});

autoFrameCamera();

}

/* CAMERA FRAME */

function autoFrameCamera(){

let box=new THREE.Box3().setFromObject(scene);
let center=box.getCenter(new THREE.Vector3());
let size=box.getSize(new THREE.Vector3());

camTarget.copy(center);

let dist=Math.max(size.x,size.y,size.z)*2+300;

camera.position.set(
center.x+dist,
center.y+dist,
center.z+dist
);

}

/* ANIMATION SIM */

function updateAnimations(){

instanceMap.forEach((obj,node)=>{

let anim=node.querySelector("Properties > string[name='AnimationId']");

if(anim){
obj.rotation.y=Math.sin(animationTime)*1.2;
}

});

}

/* START */

initEngine();

</script>
